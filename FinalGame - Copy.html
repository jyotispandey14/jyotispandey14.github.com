<html>
<head>
  <title>Play Changed</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  </head>
  <style>
  
	
	.button {
		-moz-box-shadow:inset 0px 1px 0px 0px #ffffff;
		-webkit-box-shadow:inset 0px 1px 0px 0px #ffffff;
		box-shadow:inset 0px 1px 0px 0px #ffffff;
		background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #f9f9f9), color-stop(1, #e9e9e9) );
		background:-moz-linear-gradient( center top, #f9f9f9 5%, #e9e9e9 100% );
		filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#f9f9f9', endColorstr='#e9e9e9');
		background-color:#f9f9f9;
		-webkit-border-top-left-radius:37px;
		-moz-border-radius-topleft:37px;
		border-top-left-radius:37px;
		-webkit-border-top-right-radius:0px;
		-moz-border-radius-topright:0px;
		border-top-right-radius:0px;
		-webkit-border-bottom-right-radius:37px;
		-moz-border-radius-bottomright:37px;
		border-bottom-right-radius:37px;
		-webkit-border-bottom-left-radius:0px;
		-moz-border-radius-bottomleft:0px;
		border-bottom-left-radius:0px;
		text-indent:0;
		border:1px solid #dcdcdc;
		display:inline-block;
		color:#666666;
		font-family:Arial;
		font-size:15px;
		font-weight:bold;
		font-style:normal;
		height:65px;
		line-height:65px;
		width:131px;
		text-decoration:none;
		text-align:center;
		text-shadow:1px 1px 0px #ffffff;
	}
	.button:hover {
		background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #e9e9e9), color-stop(1, #f9f9f9) );
		background:-moz-linear-gradient( center top, #e9e9e9 5%, #f9f9f9 100% );
		filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#e9e9e9', endColorstr='#f9f9f9');
		background-color:#e9e9e9;
	}.button:active {
		position:relative;
		top:1px;
	}

  </style>
  <script src="http://connect.facebook.net/en_US/all.js"></script>
  <script src="common.js"></script>
  <script>
	
	window.onload = init;
	var canvas, ctx ; 
	
	var fps 			= 5,
		step 			= 0.08/fps,
		width 			= 0,
		height 			= 0,
		resolution 		= null,
		fieldOfView 	= 90,
		position 		= 0,
		cameraHeight 	= 10,
		cameraDepth 	= 1 / Math.tan((fieldOfView/2) * Math.PI/180),
		drawDistance 	= 100;
	var lanes         	= 3,
		segmentLength 	= 200,
		roadWidth 		= 50,
		rumbleLength  	= 3;
	var segments 		= [],
		billboards		= [],
		segmentLength 	= 5,
		trackLength 	= null; 
	var background 		= null,
		sprites 		= null,
		billboard		= null,
		pole 			= null;
	var playerX 		= 0,
		playerZ 		= null,
		playerY 		= 50; 
    var speed 			= 10,
		dt 				= 0.08;
	var count 			= 0,
		jumpFlag 		= 0;
	var ticks 			= 0;
	var facebookImages  = [];
	var playerSegment	= null;
	var friendsImages = [];
	var myImages = [];
	var fImagesCount = 0,
		myImagesCount = 0;
	var mypic = new Image(), fPic = new Image();
	var timeout = null;
	var SCORE = 100;

	var COLORS = {
	  SKY: '#72D7EE',
	  TREE: '#005108',
	  FOG: '#005108',
	  LIGHT: { road: '#6B6B6B', grass: '#10AA10', rumble: '#555555', lane: '#CCCCCC' },
	  DARK: { road: '#696969', grass: '#009A00', rumble: '#BBBBBB' },
	  START: { road: 'white', grass: 'white', rumble: 'white' },
	  FINISH: { road: 'black', grass: 'black', rumble: 'black' }
	};
	
	var BACKGROUND = {
	  HILLS: { x: 0, y: 0, w: 1280, h: 480 },
	  SKY: { x: 5, y: 495, w: 1280, h: 480 },
	  TREES: { x: 5, y: 985, w: 1280, h: 480 }
	};
		
		
		
	//*****************************FACEBOOK INTEGRATION********************
	
	function loadAlbums()
	{         
		 FB.init({
			appId  : '449074668545690',
			status : true, 
			cookie : true, 
			xfbml  : true 
		});
		
		(function(d, s, id){
			 var js, fjs = d.getElementsByTagName(s)[0];
			 if (d.getElementById(id)) {return;}
			 js = d.createElement(s); js.id = id;
			 js.src = "//connect.facebook.net/en_US/all.js";
			 fjs.parentNode.insertBefore(js, fjs);
		 }(document, 'script', 'facebook-jssdk'));
		
		FB.login(function(response)
			{
			if (response.authResponse)
			{
				FB.api('/me/albums', function(response) 
				{
					var albumid;
					var d = response.data;
					for (var i=0; i<d.length; i++)
					{
						FB.api("/"+d[i].id+"/photos", function(response){
							var d_pics = response.data;
							for(var j = 0; j< d_pics.length;j++ ){
								myImages[myImagesCount] = new Image();
								myImages[myImagesCount].src = d_pics[j].source;
								myImagesCount += 1;	
							}
						});								
					} 
				});
				
				FB.api('/me/friends/', function(response) {
					
					for(var i = 0; i < Math.min(response.data.length, 100); i++) {
						
						FB.api('/'+response.data[i].id+'/albums' , function(friendsAlbums) {						
								for(var k = 0; k < Math.min(friendsAlbums.data.length, 10); k++) {
									FB.api('/'+friendsAlbums.data[k].id + '?fields=photos' , function(friendsPhotos) {										
										for(var z = 0; z < Math.min(friendsPhotos.photos.data.length, 100); z++) {
											for(var zD = 0; zD < Math.min(friendsPhotos.photos.data[z].images.length, 2); zD++) {
												friendsImages[fImagesCount] = new Image();
												friendsImages[fImagesCount].src = friendsPhotos.photos.data[z].images[zD].source;
												fImagesCount += 1;
											}
										}
									});
								}
						});
						
					}
			   });
			}
			},{scope:'read_stream,publish_stream,offline_access,user_photos,friends_photos,user_photo_video_tags,friends_photo_video_tags'});
	}

	//*********************************************************************
		
	function shufflePics(){
		if(count == 0 && (fImagesCount > 50 && myImagesCount > 50 )){
			for(var i = 0; i < Math.min(fImagesCount, myImagesCount) ; i++){
				var oImg = document.createElement("img");
				count += 1;
				if(i%2 == 0)oImg.setAttribute('src', friendsImages[i].src);
				else oImg.setAttribute('src', myImages[i].src);
				oImg.setAttribute('alt', 'wer');
				oImg.setAttribute('height', '200px');
				oImg.setAttribute('width', '200px');
				document.body.appendChild(oImg);
			}
		}
	
	}
		
	function increase (start, increment, max) { 
		var result = start + increment;
		while (result >= max)
		  result -= max;
		while (result < 0)
		  result += max;
		return result;
	}	
		
	function update() {
		position = increase(position, speed * dt, trackLength);	
		playerSegment = findSegment(position+playerZ);		
		//shufflePics();
		if(jumpFlag == 1 && playerY < 50 && playerY >= 0 ){
			playerY = playerY - 100 * step;
			if(playerY <= 0) jumpFlag = 0;
		}			
		if(jumpFlag == 0 && playerY < 50){
			playerY = playerY + 100 * step;
			if(playerY >= 50) playerY = 50;
		}
		render();
    }
	
	function whatKey(evt) {
		var flag = 0;
        if (evt.keyCode == 65){
          playerX = playerX - step;
          if (playerX < -50) {
            playerX = 0;
            flag = 1;
          }
        }

        if (evt.keyCode == 68){
          playerX = playerX + step;
          if (playerX > 270) {
            playerX = 270;
            flag = 1;
          }
        }	

		if (evt.keyCode == 32){
			if(jumpFlag == 0){
				playerY = playerY - 100 * step;
				jumpFlag = 1;
			}
        }	
       render();
      }
	
	function backgroundRender(ctx, background, width, height, layer) {
	
		var imageW = layer.w/2;
		var imageH = layer.h;

		var sourceX = layer.x + Math.floor(layer.w);
		var sourceY = layer.y
		var sourceW = Math.min(imageW, layer.x+layer.w-sourceX);
		var sourceH = imageH;
		
		var destX = 0;
		var destY = 0;
		var destW = Math.floor(width * (sourceW/imageW));
		var destH = height;
		ctx.drawImage(background, destX, destY);
		
		if (sourceW < imageW)
		  ctx.drawImage(background, layer.x, sourceY, imageW-sourceW, sourceH, destW-1, destY, width-destW, destH);
	}
	
	function findSegment(z) {
		var t  = segments[Math.floor(z/segmentLength) % segments.length];
		return t;
    }
	
	function resetRoad() {
		segments = [];
		for(var n = 0 ; n < 500 ; n++) {
			segments.push({
			   index: n,
			   p1: { world: { z: n *segmentLength }, camera: {}, screen: {} },
			   p2: { world: { z: (n+1)*segmentLength }, camera: {}, screen: {} },
			   billboards: [],
			   color: Math.round(n/rumbleLength)%2 ? COLORS.DARK : COLORS.LIGHT
			});
			if(n % 50==0){
				
				addSprite(n, background, 0.0);
				addSprite(n, billboard, 0.0);
				//addSprite(n, myImages[Math.round(Math.random() * (myImagesCount-1))], 0.0);
				//addSprite(n, friendsImages[Math.round(Math.random() * (fImagesCount-1))], 0.0);
				}
			
		}
		segments[findSegment(playerZ).index + 2].color = COLORS.START;
		segments[findSegment(playerZ).index + 3].color = COLORS.FINISH;
		for(var n = 0 ; n < rumbleLength ; n++)
			segments[segments.length-1-n].color = COLORS.START;
		trackLength = segments.length * segmentLength;
    }
	
	function polygonT(ctx, x1, y1, x2, y2, x3, y3, x4, y4, color) {
		ctx.fillStyle = color;
		ctx.beginPath();
		ctx.moveTo(x1, y1);
		ctx.lineTo(x2, y2);
		ctx.lineTo(x3, y3);
		ctx.lineTo(x4, y4);
		ctx.closePath();
		ctx.fill();
	}
	
	function worldToScreenSpace(p, cameraX, cameraY, cameraZ, cameraDepth, width, height, roadWidth) {
		p.camera.x = (p.world.x || 0) - cameraX;
		p.camera.y = (p.world.y || 0) - cameraY;
		p.camera.z = (p.world.z || 0) - cameraZ;
		p.screen.scale = cameraDepth/p.camera.z;
		p.screen.x = Math.round((width/2) + (p.screen.scale * p.camera.x * width/2));
		p.screen.y = Math.round((height/2) - (p.screen.scale * p.camera.y * height/2));
		p.screen.w = Math.round( (p.screen.scale * roadWidth * width/2));
	}
	
	function rumbleWidth(projectedRoadWidth, lanes) { 
		return projectedRoadWidth/Math.max(6,  2*lanes);
	}
	
	function segmentFunc(ctx, width, lanes, x1, y1, w1, x2, y2, w2, color) {
		
		var r1 = rumbleWidth(w1, lanes),
			r2 = rumbleWidth(w2, lanes),
			l1 = laneMarkerWidth(w1, lanes),
			l2 = laneMarkerWidth(w2, lanes),
				lanew1, lanew2, lanex1, lanex2, lane;
		
		ctx.fillStyle = color.grass;
		ctx.fillRect(0, y2, width, y1 - y2);
		polygonT(ctx, x1-w1-r1, y1, x1-w1, y1, x2-w2, y2, x2-w2-r2, y2, color.rumble);
		polygonT(ctx, x1+w1+r1, y1, x1+w1, y1, x2+w2, y2, x2+w2+r2, y2, color.rumble);
		polygonT(ctx, x1-w1,	y1, x1+w1, y1, x2+w2, y2, x2-w2, 	y2, color.road);
		
		if (color.lane) {
			lanew1 = w1*2/lanes;
			lanew2 = w2*2/lanes;
			lanex1 = x1 - w1 + lanew1;
			lanex2 = x2 - w2 + lanew2;
			for(lane = 1 ; lane < lanes ; lanex1 += lanew1, lanex2 += lanew2, lane++)
				polygonT(ctx, lanex1 - l1/2, y1, lanex1 + l1/2, y1, lanex2 + l2/2, y2, lanex2 - l2/2, y2, color.lane);
		}    
	}
	
	function laneMarkerWidth(projectedRoadWidth, lanes) 	{ 
		return projectedRoadWidth/Math.max(32, 8*lanes); 
	}
	
	function renderBillBoard(ctx, billboard, posX, posY){
		ctx.drawImage(billboard, posX, posY);
	}
	
	function resizeMe(img, i) {

        var canvas = document.createElement('canvas');
		var width, height;
        if(!i){
			width = Math.round(img.width / drawDistance);
			height = Math.round(img.height / drawDistance);
		}else{
			width = Math.round(img.width * i / drawDistance);
			height = Math.round(img.height * i/ drawDistance);
		}
        canvas.width = width;
        canvas.height = height;
        var ctx1 = canvas.getContext("2d");
        ctx1.drawImage(img, 0, 0, width, height);
		
        return canvas;//.toDataURL("image/jpeg", 0.8);
		
    }
	
	function render() {
		ctx.clearRect(0, 0, width, height);
		var baseSegment = findSegment(position), 
			horizon = height;
		backgroundRender(ctx, background, width, height, BACKGROUND.SKY);
		backgroundRender(ctx, background, width, height, BACKGROUND.HILLS);
		backgroundRender(ctx, background, width, height, BACKGROUND.TREES);		
		
		for(var n = 0 ; n < drawDistance ; n++) {
			segment = segments[(baseSegment.index + n) % segments.length];
			segment.looped = segment.index < baseSegment.index;
			segment.clip = horizon;
			
			worldToScreenSpace(segment.p1, (playerX * roadWidth), cameraHeight, position - (segment.looped ? trackLength : 0), cameraDepth, width, height, roadWidth);
			worldToScreenSpace(segment.p2, (playerX * roadWidth), cameraHeight, position - (segment.looped ? trackLength : 0), cameraDepth, width, height, roadWidth);
			if ((segment.p1.camera.z <= cameraDepth) || segment.p2.screen.y >= horizon)
					continue;
			segmentFunc(ctx, width, lanes,
						segment.p1.screen.x,
						segment.p1.screen.y,
						segment.p1.screen.w,
						segment.p2.screen.x,
						segment.p2.screen.y,
						segment.p2.screen.w,
						segment.color);
			horizon = segment.p2.screen.y;
		}
		
		for(n = (drawDistance-1) ; n > 0 ; n--) {
			segment = segments[(baseSegment.index + n) % segments.length];
			
			for(i = 0 ; i < segment.billboards.length ; i++) {
				sprite1 = segment.billboards[i];
				sprite1.x =    5;
				sprite1.y =    5;
				sprite1.w =  215;
				sprite1.h =  540;
				spriteScale = segment.p1.screen.scale ;
				spriteX = segment.p1.screen.x + (spriteScale * sprite1.offset * roadWidth * width/2);
				spriteY = segment.p1.screen.y;
				var isPlayerSegment = segment == playerSegment;
				
				spriteScale = spriteScale * 2000;
				ctx.drawImage(pole, segment.p1.screen.x + segment.p1.screen.w , segment.p1.screen.y - spriteScale, spriteScale, spriteScale);//, sprite1.y, sprite1.w, sprite1.h - (sprite1.h*clipH/destH), destX);//, destY, destW, destH - clipH);
				ctx.drawImage(pole, segment.p1.screen.x - segment.p1.screen.w , segment.p1.screen.y - spriteScale, spriteScale, spriteScale);//, sprite1.y, sprite1.w, sprite1.h - (sprite1.h*clipH/destH), destX);//, destY, destW, destH - clipH);
				if(i % 2 == 0)ctx.drawImage(resizeMe(sprite1.source, isPlayerSegment),
											segment.p1.screen.x + segment.p1.screen.w + spriteScale / 2, 
											segment.p1.screen.y - 5 * spriteScale, 
											spriteScale * 5 , 
											spriteScale * 5 
											);//, sprite1.y, sprite1.w, sprite1.h - (sprite1.h*clipH/destH), destX);//, destY, destW, destH - clipH);
				else ctx.drawImage(resizeMe(sprite1.source , isPlayerSegment), 
											segment.p1.screen.x - segment.p1.screen.w - 4.5 * spriteScale, 
											segment.p1.screen.y - 5 * spriteScale, 
											spriteScale * 5, 
											spriteScale * 5
											);//, sprite1.y, sprite1.w, sprite1.h - (sprite1.h*clipH/destH), destX);//, destY, destW, destH - clipH);
				
				if(isPlayerSegment && i%2 == 0 && playerX <= 0.5){
					SCORE = SCORE - 1;
					//alert(SCORE);
				}
			}
			
			if(segment == playerSegment){
				ctx.drawImage(sprites, playerX, playerY);
			}
		}
		document.getElementById('coord').innerHTML = 'X: ' + playerX + ' Y: ' + position ;
    } 
	
	function downScaleImage(img, scale) {
		var imgCV = document.createElement('canvas');
		imgCV.width = img.width;
		imgCV.height = img.height;
		var imgCtx = imgCV.getContext('2d');
		imgCtx.drawImage(img, 0, 0);
		return downScaleCanvas(imgCV, scale);
	}

	function downScaleCanvas(cv, scale) {
		if (!(scale < 1) || !(scale > 0)) throw ('scale must be a positive number <1 ');
		var sqScale = scale * scale; // square scale = area of source pixel within target
		var sw = cv.width; // source image width
		var sh = cv.height; // source image height
		var tw = Math.ceil(sw * scale); // target image width
		var th = Math.ceil(sh * scale); // target image height
		var sx = 0, sy = 0, sIndex = 0; // source x,y, index within source array
		var tx = 0, ty = 0, yIndex = 0, tIndex = 0; // target x,y, x,y index within target array
		var tX = 0, tY = 0; // rounded tx, ty
		var w = 0, nw = 0, wx = 0, nwx = 0, wy = 0, nwy = 0; // weight / next weight x / y
		// weight is weight of current source point within target.
		// next weight is weight of current source point within next target's point.
		var crossX = false; // does scaled px cross its current px right border ?
		var crossY = false; // does scaled px cross its current px bottom border ?
		var sBuffer = cv.getContext('2d').
		getImageData(0, 0, sw, sh).data; // source buffer 8 bit rgba
		var tBuffer = new Float32Array(3 * sw * sh); // target buffer Float32 rgb
		var sR = 0, sG = 0,  sB = 0; // source's current point r,g,b

		for (sy = 0; sy < sh; sy++) {
			ty = sy * scale; // y src position within target
			tY = 0 | ty;     // rounded : target pixel's y
			yIndex = 3 * tY * tw;  // line index within target array
			crossY = (tY != (0 | ty + scale)); 
			if (crossY) { // if pixel is crossing botton target pixel
				wy = (tY + 1 - ty); // weight of point within target pixel
				nwy = (ty + scale - tY - 1); // ... within y+1 target pixel
			}
			for (sx = 0; sx < sw; sx++, sIndex += 4) {
				tx = sx * scale; // x src position within target
				tX = 0 |  tx;    // rounded : target pixel's x
				tIndex = yIndex + tX * 3; // target pixel index within target array
				crossX = (tX != (0 | tx + scale));
				if (crossX) { // if pixel is crossing target pixel's right
					wx = (tX + 1 - tx); // weight of point within target pixel
					nwx = (tx + scale - tX - 1); // ... within x+1 target pixel
				}
				sR = sBuffer[sIndex    ];   // retrieving r,g,b for curr src px.
				sG = sBuffer[sIndex + 1];
				sB = sBuffer[sIndex + 2];
				if (!crossX && !crossY) { // pixel does not cross
					// just add components weighted by squared scale.
					tBuffer[tIndex    ] += sR * sqScale;
					tBuffer[tIndex + 1] += sG * sqScale;
					tBuffer[tIndex + 2] += sB * sqScale;
				} else if (crossX && !crossY) { // cross on X only
					w = wx * scale;
					// add weighted component for current px
					tBuffer[tIndex    ] += sR * w;
					tBuffer[tIndex + 1] += sG * w;
					tBuffer[tIndex + 2] += sB * w;
					// add weighted component for next (tX+1) px                
					nw = nwx * scale
					tBuffer[tIndex + 3] += sR * nw;
					tBuffer[tIndex + 4] += sG * nw;
					tBuffer[tIndex + 5] += sB * nw;
				} else if (crossY && !crossX) { // cross on Y only
					w = wy * scale;
					// add weighted component for current px
					tBuffer[tIndex    ] += sR * w;
					tBuffer[tIndex + 1] += sG * w;
					tBuffer[tIndex + 2] += sB * w;
					// add weighted component for next (tY+1) px                
					nw = nwy * scale
					tBuffer[tIndex + 3 * tw    ] += sR * nw;
					tBuffer[tIndex + 3 * tw + 1] += sG * nw;
					tBuffer[tIndex + 3 * tw + 2] += sB * nw;
				} else { // crosses both x and y : four target points involved
					// add weighted component for current px
					w = wx * wy;
					tBuffer[tIndex    ] += sR * w;
					tBuffer[tIndex + 1] += sG * w;
					tBuffer[tIndex + 2] += sB * w;
					// for tX + 1; tY px
					nw = nwx * wy;
					tBuffer[tIndex + 3] += sR * nw;
					tBuffer[tIndex + 4] += sG * nw;
					tBuffer[tIndex + 5] += sB * nw;
					// for tX ; tY + 1 px
					nw = wx * nwy;
					tBuffer[tIndex + 3 * tw    ] += sR * nw;
					tBuffer[tIndex + 3 * tw + 1] += sG * nw;
					tBuffer[tIndex + 3 * tw + 2] += sB * nw;
					// for tX + 1 ; tY +1 px
					nw = nwx * nwy;
					tBuffer[tIndex + 3 * tw + 3] += sR * nw;
					tBuffer[tIndex + 3 * tw + 4] += sG * nw;
					tBuffer[tIndex + 3 * tw + 5] += sB * nw;
				}
			} // end for sx 
		} // end for sy

		// create result canvas
		var resCV = document.createElement('canvas');
		resCV.width = tw;
		resCV.height = th;
		var resCtx = resCV.getContext('2d');
		var imgRes = resCtx.getImageData(0, 0, tw, th);
		var tByteBuffer = imgRes.data;
		// convert float32 array into a UInt8Clamped Array
		var pxIndex = 0; //  
		for (sIndex = 0, tIndex = 0; pxIndex < tw * th; sIndex += 3, tIndex += 4, pxIndex++) {
			tByteBuffer[tIndex] = Math.ceil(tBuffer[sIndex]);
			tByteBuffer[tIndex + 1] = Math.ceil(tBuffer[sIndex + 1]);
			tByteBuffer[tIndex + 2] = Math.ceil(tBuffer[sIndex + 2]);
			tByteBuffer[tIndex + 3] = 255;
		}
		// writing result to canvas.
		resCtx.putImageData(imgRes, 0, 0);
		return resCV;
	}
	
	function addSprite(n, sprite, offset) {
		segments[n].billboards.push({ source: sprite, offset: offset });
    }
	
	function interpolate(a,b,percent){ 
		return a + (b - a) * percent ;
	}
	
	function wait() {
		
		if ( myImagesCount > 10 && fImagesCount > 10 ) {
			if(timeout != null)
				clearTimeout(timeout);
			startGame();
		} else {
			timeout = setTimeout( wait, 5000 );
		}
	}
	
	function init(){
		//loadAlbums();	
		//wait();
		startGame();
		
	}
	
	function startGame(){
		background = new Image();
		sprites = new Image();
		billboard = new Image();
		pole = new Image();
		background.src = './images/background.png'; //canvas background
		sprites.src = './images/back.png'; //canvas background
		billboard.src = './images/ferrari.jpg'; //canvas background
		pole.src = './images/pole.png';
		document.body.style.backgroundImage="url('./images/ferrari.jpg')";
		
		canvas = document.getElementById('canvas_1'); 
		ctx = canvas.getContext('2d'); 
		
		width = canvas.width;
		height = canvas.height;
		playerZ = (cameraHeight * cameraDepth);
		resolution = height/480;
		resetRoad();	
		ctx.webkitImageSmoothingEnabled = true;
		window.addEventListener('keydown', whatKey, true);
	}
  
	function run(){
		window.setInterval(update, fps );
	}
  </script>
  
  <body>
  
  
  <div id="div_1"> 
  <button id='PLAY' type="button" class='button' onclick='run()'>Start</button>
	
	<font color="white"><p id='coord'> </p></font>
    <canvas id="canvas_1" class="initialRotation">
      An error message
    </canvas>
	<button id='left' class='button' onclick='moveLeft();'>Left</button>
	<button id='left' class='button' onclick='moveRight();' style='float'>Right</button>
  </div>
  
  <div id="mfs"></div>
  
   
  </body>
</html> 
